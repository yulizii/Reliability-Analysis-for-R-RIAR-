---
title: "Intro and Examples"
author: "Jiarui Gan"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Intro and Examples}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Overview

**riar** is a simple R package developed to calculate the failure probability in reliability analysis(RIA) for the 'Statistical Computing' course. Four functions are considered, namely, *train_svm* (Train the svm model based on labels) and *predict_svm* (Predicting the failure probability on the basis of the trained model),*MCS*(Calculate failure probability via Mento Carlo simulation), *form*(Calculate failure probability viaFirst Order Reliabilify Method) . *form* is produced by Rcpp for the sake of gradient computation.

## Example 1: RIA-SVM for R

Support Vector Machine (SVM) is a supervised learning algorithm used in reliability analysis to classify data and predict system failures by finding the optimal hyperplane that separates data into distinct classes, enhancing decision-making for maintenance and risk management.

Thanks to the Rpackage: e1071(CRAN: Package e1071), which makes the SVM method for RIA much easier.

To calculate, you should enter the limit state function ( call it g(x)) and some train data( call them x), and just use the function \*train_svm\* to train the svm model. Eventually you can use the trained svm model to predict the failure probability and reliability index.

```{r example1}
library(riar)
set.seed(123)
g <- function(x) {
  return(x[1]^2 + x[2]^2 - 3)
}
n_samples <- 500  # Define the number of samples
x <- matrix(rnorm(2*n_samples), ncol = 2)
svm_model <- train_svm(x, g)  # Train the SVM model
results <- predict_svm(svm_model, x, g)  # Predict failure probability and reliability index
print(results)  # Print the results
```

## Example 2: RIA-MCS for R

Mento Carlo simulation ( MCS ) went viral in past 50 years in RIA, though, it has not been exploited via R. In order to compare the failure probability generated by other methods, MCS may be essential.

MCS is easy to implement, just put the limit state funciton (g(x)) and samples(x) into the \*MCS()\*, the failure probability and reliability index can be calculated.

```{R}
# Example limit state function
g_example <- function(sample) {
  return(sample[1] + sample[2] - 2)  # Example limit state function
}

# Example sample set
set.seed(123)
samples <- matrix(rnorm(1000), ncol = 2)  # Generate random samples

# Calculate failure probability
result <- MCS(samples, g_example)
print(result)
```

## Example 3: RIA-FORM for R

The First Order Reliability Method (FORM) is a probabilistic analysis technique used in reliability engineering to estimate the failure probability of systems. It approximates the limit state function linearly at the design point, providing an efficient way to assess structural safety and performance under uncertainty.

Cause \*form\* is based on a transformation of space, you should put the samples' mean values and variance values into the function, not the samples themselves. Then the failure probability and reliability index can be calculated.

```{r}
library(Rcpp)

# Limist State Function
g <- function(x) {
  x[1] + x[2] - 5
}

# Mean and Variance
mean <- c(3, 2)
sigma <- c(1, 1)

# Result based on form
result <- form(g, mean, sigma)
print(result)

```

### Appendix: form code
```{Rcpp}
#include <Rcpp.h>
#include <cmath>

using namespace Rcpp;

//' @title FORM Algorithm using Rcpp
//' @name form
//' @description Calculates the failure probability and reliability index using the FORM algorithm
//' @param g A function representing the limit state function
//' @param mean A NumericVector of the mean values of the input variables
//' @param sigma A NumericVector of the standard deviations of the input variables
//' @return A List with failure probability \code{pf} and reliability index \code{beta}
//' @examples
//' \dontrun{
//' g <- function(x) { x[1] + x[2] - 3 }
//' mean <- c(2, 2)
//' sigma <- c(1, 1)
//' result <- form(g, mean, sigma)
//' print(result)
//' }
//' @export
// [[Rcpp::export]]
 List form(Function g, NumericVector mean, NumericVector sigma) {
   int n = mean.size(); // Number of variables
   NumericVector u = mean / sigma; // Initial guess in standard normal space
   NumericVector grad(n);          // Gradient vector
   double beta = 0.0, beta_prev;   // Reliability index
   double tol = 1e-6;              // Convergence tolerance
   int max_iter = 100;             // Maximum iterations

   // Iterative optimization
   for (int iter = 0; iter < max_iter; ++iter) {
     // Compute gradient and g value
     NumericVector x = mean + sigma * u; // Map back to original space
     double g_val = as<double>(g(x));

     // Numerical gradient approximation
     for (int i = 0; i < n; ++i) {
       NumericVector x_eps = clone(x);
       double eps = 1e-5; // Small perturbation
       x_eps[i] += eps;
       grad[i] = (as<double>(g(x_eps)) - g_val) / eps;
     }

     // Update beta and u
     double grad_norm = sum(pow(grad, 2.0));
     if (grad_norm == 0) stop("Gradient norm is zero, optimization cannot proceed.");
     grad = grad / std::sqrt(grad_norm); // Normalize gradient
     beta_prev = beta;
     beta = -g_val / std::sqrt(grad_norm); // Update reliability index
     u = -beta * grad; // Update u

     // Check for convergence
     if (std::abs(beta - beta_prev) < tol) break;
   }

   // Compute failure probability
   double pf = R::pnorm(-beta, 0.0, 1.0, 1, 0); // Standard normal CDF

   // Return results
   return List::create(
     Named("pf") = pf,
     Named("beta") = beta
   );
 }

```
